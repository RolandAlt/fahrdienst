Benutzer: Roland.alt@gmx.de
Password: Ms1779p$


https://supabase.com/dashboard/project/fckacniifbgbtcwyfnta/editor/17452

https://supabase.com/dashboard/project/fckacniifbgbtcwyfnta/editor/22840?schema=public


Datenbank Passwort: Subaybayt66Ms1779p$


Verbindung Daten:
Project URL: 

https://fckacniifbgbtcwyfnta.supabase.co


Lagacy API Key - Anon Public API Key:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZja2FjbmlpZmJnYnRjd3lmbnRhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE5ODc3NzMsImV4cCI6MjA3NzU2Mzc3M30.hTJOkXOMvVCpdjo03U46Ps9NFGyzbskdt0n9ngiyYEk



User:
roland.alt@gmx.de - Subaybay66
roland.alt1962@gmx.de - Subaybay66





create table public."Einrichtungen" (
  row_id bigint generated by default as identity not null,
  "Aktiv" boolean not null default true,
  "Adresse der Einrichtung" text null,
  "Name der Einrichtung" text not null,
  "Telefonnummer der Einrichtung 1" text null,
  "Telefonnummer der Einrichtung 2" text null,
  "Telefonnummer der Einrichtung 3" text null,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  created_by uuid null,
  updated_by uuid null,
  logo_url text null,
  constraint Einrichtungen_pkey primary key (row_id)
) TABLESPACE pg_default;

create trigger trg_einrichtungen_user_ts BEFORE INSERT
or
update on "Einrichtungen" for EACH row
execute FUNCTION set_user_and_timestamps ();


create table public."Fahrzeuge" (
  row_id bigint generated by default as identity not null,
  "Einrichtungen row_id" bigint null,
  "Fahrzeug Kurz" text not null,
  "Kennzeichen" text not null,
  "Bezeichnung" text null,
  "Sitzplätze" integer null,
  "Aktiv" boolean not null default true,
  "Notizen" text null,
  "Anzeige" boolean null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  constraint Fahrzeuge_pkey primary key (row_id),
  constraint fahrzeuge_einrichtungen_fk foreign KEY ("Einrichtungen row_id") references "Einrichtungen" (row_id) on update CASCADE on delete set null not VALID
) TABLESPACE pg_default;

create index IF not exists idx_fahrzeuge_kennzeichen on public."Fahrzeuge" using btree ("Kennzeichen") TABLESPACE pg_default;

create index IF not exists idx_fahrzeuge_kurz on public."Fahrzeuge" using btree ("Fahrzeug Kurz") TABLESPACE pg_default;

create index IF not exists idx_fahrzeuge_einrichtung on public."Fahrzeuge" using btree ("Einrichtungen row_id") TABLESPACE pg_default;

create trigger trg_fahrzeuge_user_ts BEFORE INSERT
or
update on "Fahrzeuge" for EACH row
execute FUNCTION set_user_and_timestamps ();


create table public."Klienten" (
  row_id bigint generated by default as identity not null,
  "Einrichtungen row_id" bigint null,
  "Aktiv" boolean not null default true,
  "Nr." bigint null,
  "Name" text not null,
  "Vorname" text null,
  "Adresse" text null,
  "Ortsteil" text null,
  "Telefon" text null,
  "Angehörige" text null,
  "Angehörige Tel." text null,
  "Betreuer" text null,
  "Betreuer Tel." text null,
  "RS" boolean not null default false,
  "Besonderheiten" text null,
  "Infos zur Wohnsituation" text null,
  "Tagespflege (Wochentage)" text null,
  "Fahrdienst" boolean not null default true,
  "Hilfe bei" text null,
  "Schlüssel" text null,
  "Klingelzeichen" text null,
  "Sonstige Informationen" text null,
  last_editor text null,
  last_editor_device text null,
  last_editor_device_name text null,
  last_editor_device_id text null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  constraint klienten_pkey primary key (row_id),
  constraint klienten_einrichtungen_fk foreign KEY ("Einrichtungen row_id") references "Einrichtungen" (row_id) on update CASCADE on delete set null not VALID
) TABLESPACE pg_default;

create index IF not exists idx_klienten_einr_rowid on public."Klienten" using btree ("Einrichtungen row_id") TABLESPACE pg_default;

create trigger trg_klienten_user_ts BEFORE INSERT
or
update on "Klienten" for EACH row
execute FUNCTION set_user_and_timestamps ();






create table public."Mitarbeiter" (
  row_id bigint generated by default as identity not null,
  "Einrichtungen row_id" bigint null,
  "Aktiv" boolean not null default true,
  "Nr." bigint null,
  "Name" text not null,
  "Vorname" text null,
  "Adresse" text null,
  "Ortsteil" text null,
  "Telefonnummer 1" text null,
  "Telefonnummer 2" text null,
  "Telefonnummer 3" text null,
  "E-Mail-Adresse" text null,
  "Geburtsdatum" date null,
  "Arbeitsbeginn Datum" date null,
  "Funktion" bigint null,
  "Bemerkung" text null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  auth_user_id uuid null,
  darf_dienstplan boolean not null default false,
  constraint Mitarbeiter_pkey primary key (row_id),
  constraint mitarbeiter_auth_user_id_fkey foreign KEY (auth_user_id) references auth.users (id) on delete set null,
  constraint mitarbeiter_einrichtungen_fk foreign KEY ("Einrichtungen row_id") references "Einrichtungen" (row_id) on update CASCADE on delete set null not VALID,
  constraint mitarbeiter_funktion_fk foreign KEY ("Funktion") references "Mitarbeiter Funktion" (row_id) on update CASCADE on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_mitarbeiter_funktion_fk on public."Mitarbeiter" using btree ("Funktion") TABLESPACE pg_default;

create unique INDEX IF not exists mitarbeiter_auth_user_id_uidx on public."Mitarbeiter" using btree (auth_user_id) TABLESPACE pg_default
where
  (auth_user_id is not null);

create index IF not exists idx_mitarbeiter_name on public."Mitarbeiter" using btree ("Name") TABLESPACE pg_default;

create index IF not exists idx_mitarbeiter_nr on public."Mitarbeiter" using btree ("Nr.") TABLESPACE pg_default;

create index IF not exists idx_mitarbeiter_einrichtung on public."Mitarbeiter" using btree ("Einrichtungen row_id") TABLESPACE pg_default;

create trigger trg_mitarbeiter_user_ts BEFORE INSERT
or
update on "Mitarbeiter" for EACH row
execute FUNCTION set_user_and_timestamps ();



create table public."Mitarbeiter Funktion" (
  row_id bigint generated by default as identity not null,
  "Funktion" text not null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  constraint Mitarbeiter Funktion_pkey primary key (row_id)
) TABLESPACE pg_default;

create index IF not exists idx_mitarbeiter_funktion_name on public."Mitarbeiter Funktion" using btree ("Funktion") TABLESPACE pg_default;

create trigger trg_mitarbeiter_funktion_user_ts BEFORE INSERT
or
update on "Mitarbeiter Funktion" for EACH row
execute FUNCTION set_user_and_timestamps ();


create table public."Dienstplan" (
  "Wochenbeginn" date not null,
  "Mitarbeiter row_ID" bigint not null,
  "Fahrzeuge row_id Mo" bigint null,
  "Fahrzeuge row_id Di" bigint null,
  "Fahrzeuge row_id Mi" bigint null,
  "Fahrzeuge row_id Do" bigint null,
  "Fahrzeuge row_id Fr" bigint null,
  "Fahrzeuge row_id Sa" bigint null,
  "Fahrzeuge row_id Su" bigint null,
  "Bemerkung" text null,
  row_id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  "Status_Mo" smallint not null default '0'::smallint,
  "Status_Di" smallint not null default '0'::smallint,
  "Status_Mi" smallint not null default '0'::smallint,
  "Status_Do" smallint not null default '0'::smallint,
  "Status_Fr" smallint not null default '0'::smallint,
  "Status_Sa" smallint not null default '0'::smallint,
  "Status_So" smallint not null default '0'::smallint,
  constraint Dienstplan_pkey primary key (row_id),
  constraint dienstplan_mitarbeiter_woche_uniq unique ("Mitarbeiter row_ID", "Wochenbeginn"),
  constraint dienstplan_fzg_do_fk foreign KEY ("Fahrzeuge row_id Do") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_fzg_fr_fk foreign KEY ("Fahrzeuge row_id Fr") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_fzg_mi_fk foreign KEY ("Fahrzeuge row_id Mi") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_fzg_sa_fk foreign KEY ("Fahrzeuge row_id Sa") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_fzg_su_fk foreign KEY ("Fahrzeuge row_id Su") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_mitarbeiter_fk foreign KEY ("Mitarbeiter row_ID") references "Mitarbeiter" (row_id) on update CASCADE on delete CASCADE,
  constraint dienstplan_fzg_mo_fk foreign KEY ("Fahrzeuge row_id Mo") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_fzg_di_fk foreign KEY ("Fahrzeuge row_id Di") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint dienstplan_status_range_chk check (
    (
      (
        ("Status_Mo" >= 0)
        and ("Status_Mo" <= 3)
      )
      and (
        ("Status_Di" >= 0)
        and ("Status_Di" <= 3)
      )
      and (
        ("Status_Mi" >= 0)
        and ("Status_Mi" <= 3)
      )
      and (
        ("Status_Do" >= 0)
        and ("Status_Do" <= 3)
      )
      and (
        ("Status_Fr" >= 0)
        and ("Status_Fr" <= 3)
      )
      and (
        ("Status_Sa" >= 0)
        and ("Status_Sa" <= 3)
      )
      and (
        ("Status_So" >= 0)
        and ("Status_So" <= 3)
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_dienstplan_wochenbeginn on public."Dienstplan" using btree ("Wochenbeginn") TABLESPACE pg_default;

create index IF not exists idx_dienstplan_mitarbeiter on public."Dienstplan" using btree ("Mitarbeiter row_ID") TABLESPACE pg_default;

create trigger trg_dienstplan_user_ts BEFORE INSERT
or
update on "Dienstplan" for EACH row
execute FUNCTION set_user_and_timestamps ();



create table public."Tagesplan" (
  "Datum" date not null,
  "Klienten row_id" bigint null,
  "Fahrzeuge row_id Morgen" bigint null,
  "Fahrzeuge row_id Abend" bigint null,
  "Reihenfolge Morgen" integer null,
  "Reihenfolge Abend" integer null,
  "Bemerkung" text null,
  row_id bigint generated by default as identity not null,
  last_editor text null,
  last_editor_device text null,
  last_editor_device_name text null,
  last_editor_device_id text null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  updated_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  created_by uuid null,
  updated_by uuid null,
  constraint tagesplan_pkey primary key (row_id),
  constraint tagesplan_fzg_abend_fk foreign KEY ("Fahrzeuge row_id Abend") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint tagesplan_fzg_morgen_fk foreign KEY ("Fahrzeuge row_id Morgen") references "Fahrzeuge" (row_id) on update CASCADE on delete set null,
  constraint tagesplan_klienten_fk foreign KEY ("Klienten row_id") references "Klienten" (row_id) on update CASCADE on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_tagesplan_fzg_m on public."Tagesplan" using btree ("Fahrzeuge row_id Morgen") TABLESPACE pg_default;

create index IF not exists idx_tagesplan_fzg_a on public."Tagesplan" using btree ("Fahrzeuge row_id Abend") TABLESPACE pg_default;

create index IF not exists idx_tagesplan_datum on public."Tagesplan" using btree ("Datum") TABLESPACE pg_default;

create index IF not exists idx_tagesplan_klient on public."Tagesplan" using btree ("Klienten row_id") TABLESPACE pg_default;

create trigger trg_tagesplan_user_ts BEFORE INSERT
or
update on "Tagesplan" for EACH row
execute FUNCTION set_user_and_timestamps ();




Und Hier die Datenbank Funktionen:

declare
  claims jsonb;
  uid uuid;
begin
  -- 1) Timestamps (immer als timestamptz)
  if tg_op = 'INSERT' then
    if new.created_at is null then new.created_at := now(); end if;
    new.updated_at := coalesce(new.updated_at, new.created_at, now());
  elsif tg_op = 'UPDATE' then
    new.updated_at := now();
  end if;

  -- 2) User-ID ermitteln (JWT -> sub; sonst auth.uid(); sonst NULL)
  begin
    claims := current_setting('request.jwt.claims', true)::jsonb;
  exception when others then
    claims := null;
  end;

  if claims ? 'sub' then
    uid := nullif(claims->>'sub','')::uuid;
  end if;

  if uid is null then
    uid := auth.uid(); -- kann NULL sein, wenn kein Auth-Kontext
  end if;

  -- 3) created_by / updated_by setzen
  if tg_op = 'INSERT' then
    if new.created_by is null then new.created_by := uid; end if;
    if new.updated_by is null then new.updated_by := coalesce(uid, new.created_by); end if;
  else
    new.updated_by := coalesce(uid, new.updated_by);
  end if;

  return new;
end;


Daten Tagesplan importieren aus Sheet:
Zuerst Temp Tabelle erstellen:
Dann manuell CVS importieren in Temp
Dann aus Temp in Tagesplan


-- =====================================================================
-- setup_tagesplan_import.sql
-- Erzeugt eine frische temporäre Tabelle zum CSV-Import aus Google Sheet
-- =====================================================================

drop table if exists public.tagesplan_import;

create table public.tagesplan_import (
  id serial primary key,
  "Datum"                           text,
  "Klienten row_id"                 text,
  "Fahrzeuge row_id"                text,   -- wird ignoriert
  "Fahrzeuge row_id Morgen"         text,
  "Fahrzeuge row_id Abend"          text,
  "Reihenfolge Morgen"              text,
  "Reihenfolge Abend"               text,
  "Bemerkung"                       text,
  "row_id"                          text,   -- aus Sheet, wird NICHT übernommen
  "updated_at"                      text,   -- Trigger setzt selbst timestamps
  "last_editor"                     text,
  "last_editor_device"              text,
  "last_editor_device_name"         text,
  "last_editor_device_id"           text
);

comment on table public.tagesplan_import is
  'Temporäre Importtabelle für CSV-Daten aus Google Sheets (Tagesplan).';

-- Nach diesem Schritt CSV importieren (z. B. via Supabase Table Editor / Import)



-- =====================================================================
-- import_to_tagesplan.sql
-- Übernimmt Daten aus tagesplan_import in die Haupttabelle "Tagesplan"
-- =====================================================================

-- Einmalig sicherstellen, dass es einen Unique-Index für den Upsert gibt:
do $$
begin
  if not exists (
    select 1 from pg_indexes
    where schemaname='public' and indexname='uq_tagesplan_datum_klient'
  ) then
    execute 'create unique index uq_tagesplan_datum_klient
             on public."Tagesplan" ("Datum","Klienten row_id")';
  end if;
end$$;

-- Jetzt eigentlicher Import / Upsert:
insert into public."Tagesplan" (
  "Datum",
  "Klienten row_id",
  "Fahrzeuge row_id Morgen",
  "Fahrzeuge row_id Abend",
  "Reihenfolge Morgen",
  "Reihenfolge Abend",
  "Bemerkung",
  last_editor,
  last_editor_device,
  last_editor_device_name,
  last_editor_device_id
)
select
  case when nullif(trim(r."Datum"), '') is not null
       then to_date(r."Datum", 'DD.MM.YYYY')
       else null end                                        as "Datum",

  case when r."Klienten row_id" ~ '^\s*\d+'
       then regexp_replace(r."Klienten row_id", '^\s*(\d+).*', '\1')::bigint
       else null end                                        as "Klienten row_id",

  case when nullif(trim(r."Fahrzeuge row_id Morgen"), '') is not null
            and r."Fahrzeuge row_id Morgen" ~ '^\s*\d+'
       then regexp_replace(r."Fahrzeuge row_id Morgen", '^\s*(\d+).*', '\1')::bigint
       else null end                                        as "Fahrzeuge row_id Morgen",

  case when nullif(trim(r."Fahrzeuge row_id Abend"), '') is not null
            and r."Fahrzeuge row_id Abend" ~ '^\s*\d+'
       then regexp_replace(r."Fahrzeuge row_id Abend", '^\s*(\d+).*', '\1')::bigint
       else null end                                        as "Fahrzeuge row_id Abend",

  case when nullif(trim(r."Reihenfolge Morgen"), '') is not null
       then nullif(trim(r."Reihenfolge Morgen"), '')::int
       else null end                                        as "Reihenfolge Morgen",

  case when nullif(trim(r."Reihenfolge Abend"), '') is not null
       then nullif(trim(r."Reihenfolge Abend"), '')::int
       else null end                                        as "Reihenfolge Abend",

  nullif(r."Bemerkung", '')                                 as "Bemerkung",
  nullif(r."last_editor", '')                               as last_editor,
  nullif(r."last_editor_device", '')                        as last_editor_device,
  nullif(r."last_editor_device_name", '')                   as last_editor_device_name,
  nullif(r."last_editor_device_id", '')                     as last_editor_device_id
from public.tagesplan_import r

on conflict ("Datum","Klienten row_id") do update
set
  "Fahrzeuge row_id Morgen" = excluded."Fahrzeuge row_id Morgen",
  "Fahrzeuge row_id Abend"  = excluded."Fahrzeuge row_id Abend",
  "Reihenfolge Morgen"      = excluded."Reihenfolge Morgen",
  "Reihenfolge Abend"       = excluded."Reihenfolge Abend",
  "Bemerkung"               = excluded."Bemerkung",
  last_editor               = excluded.last_editor,
  last_editor_device        = excluded.last_editor_device,
  last_editor_device_name   = excluded.last_editor_device_name,
  last_editor_device_id     = excluded.last_editor_device_id;

-- Optional: nach erfolgreichem Import aufräumen
-- truncate table public.tagesplan_import;




Alle Policy erneuern: Enable RLS and Grant Authenticated Full Table Access

-- 0) RLS aktivieren (ohne RLS greifen Policies nicht)
alter table public."Einrichtungen"          enable row level security;
alter table public."Fahrzeuge"              enable row level security;
alter table public."Klienten"               enable row level security;
alter table public."Mitarbeiter"            enable row level security;
alter table public."Mitarbeiter Funktion"   enable row level security;
alter table public."Dienstplan"            enable row level security;
alter table public."Tagesplan"              enable row level security;

-- 1) Pro Tabelle alle-erlaubt-Policies für authenticated setzen
do $$
declare
  tbl text;
  psel text; pins text; pupd text; pdel text;
begin
  foreach tbl in array array[
    'Einrichtungen',
    'Fahrzeuge',
    'Klienten',
    'Mitarbeiter',
    'Mitarbeiter Funktion',
    'Dienstplan',
    'Tagesplan'
  ]
  loop
    psel := format('%s_select_auth_all', replace(lower(tbl),' ','_'));
    pins := format('%s_insert_auth_all', replace(lower(tbl),' ','_'));
    pupd := format('%s_update_auth_all', replace(lower(tbl),' ','_'));
    pdel := format('%s_delete_auth_all', replace(lower(tbl),' ','_'));

    execute format('drop policy if exists "%I" on public.%I;', psel, tbl);
    execute format('drop policy if exists "%I" on public.%I;', pins, tbl);
    execute format('drop policy if exists "%I" on public.%I;', pupd, tbl);
    execute format('drop policy if exists "%I" on public.%I;', pdel, tbl);

    -- SELECT: alle eingeloggten Nutzer dürfen alles lesen
    execute format($f$
      create policy "%I" on public.%I
      for select to authenticated
      using (true);
    $f$, psel, tbl);

    -- INSERT: alle eingeloggten Nutzer dürfen alles einfügen
    execute format($f$
      create policy "%I" on public.%I
      for insert to authenticated
      with check (true);
    $f$, pins, tbl);

    -- UPDATE: alle eingeloggten Nutzer dürfen alles ändern
    execute format($f$
      create policy "%I" on public.%I
      for update to authenticated
      using (true)
      with check (true);
    $f$, pupd, tbl);

    -- DELETE: alle eingeloggten Nutzer dürfen alles löschen (optional)
    execute format($f$
      create policy "%I" on public.%I
      for delete to authenticated
      using (true);
    $f$, pdel, tbl);
  end loop;
end $$;
